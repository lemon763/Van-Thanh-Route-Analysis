# -*- coding: utf-8 -*-
"""CHÍNH PHÂN ĐIỂM VÀ MERGE ĐIỂM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1acZ8ntdDJ9Aq0_ECOzO53MA9XZI86zjW
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install python-Levenshtein

!pip install fuzzywuzzy[speedup]

!pip install opencage

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from fuzzywuzzy import process
import os
from shapely.geometry import Point, LineString, Polygon
from geopy.distance import geodesic
import folium
import ast
from rapidfuzz import process, fuzz

# Đọc dữ liệu về các tuyến đường (layer)
layers_df = pd.read_csv("/content/drive/MyDrive/Data/CSV_map_files/combined_kml_data.csv")
# Đọc dữ liệu khách hàng
customers_df = pd.read_excel("/content/drive/MyDrive/Data/Dữ liệu tuyến, khách hàng cần thiết/Danh sách khách hàng 3 kinh, vĩ độ.xlsx")
# Đọc dữ liệu tuyến xe mới
tuyen_xe_moi_df = pd.read_excel('/content/drive/MyDrive/Data/Dữ liệu tuyến, khách hàng cần thiết/Tuyến xe mới_Chính.xlsx')

# Chuyển đổi cột Kinh Độ và Vĩ Độ sang kiểu float
customers_df['Kinh Độ'] = pd.to_numeric(customers_df['Kinh Độ'], errors='coerce')
customers_df['Vĩ Độ'] = pd.to_numeric(customers_df['Vĩ Độ'], errors='coerce')

# Hàm tạo LineString hoặc Polygon từ danh sách tọa độ
def create_geometry(coord_string, geom_type):
    coords = ast.literal_eval(coord_string)
    if geom_type == 'LineString':
        return LineString(coords)
    elif geom_type == 'Polygon':
        if coords[0] != coords[-1]:
            coords.append(coords[0])
        return Polygon(coords)

# Thêm cột hình học (LineString hoặc Polygon) vào DataFrame tuyến đường
layers_df['geometry'] = layers_df.apply(lambda row: create_geometry(row['Coordinates'], row['Type']), axis=1)

# Hàm kiểm tra điểm trong Polygon
def is_point_in_polygon(point, polygon):
    return polygon.contains(point)

# Hàm kiểm tra điểm gần LineString với ngưỡng 100m
def is_point_near_linestring(point, linestring, threshold=0.1):
    return linestring.distance(point) <= threshold

# Gán Tuyến Cố Định và Gán Tuyến Linh Hoạt
def assign_routes(row, layers):
    if pd.isna(row['Kinh Độ']) or pd.isna(row['Vĩ Độ']):
        return ('Chưa xác định', 'Chưa xác định', 'Chưa xác định')

    customer_point = Point(row['Kinh Độ'], row['Vĩ Độ'])
    fixed_route = []
    flexible_route = []

    # Check if the point is inside a polygon
    for _, layer in layers.iterrows():
        geometry = layer['geometry']
        if isinstance(geometry, Polygon) and is_point_in_polygon(customer_point, geometry):
            fixed_route.append(layer['Folder Name (Khu Vực)'])

    # Check if the point is near any lines
    for _, layer in layers.iterrows():
        geometry = layer['geometry']
        if isinstance(geometry, LineString) and is_point_near_linestring(customer_point, geometry):
            flexible_route.append(layer['Folder Name (Khu Vực)'])

    # Assign based on the number of routes found
    if len(fixed_route) == 1:
        return (fixed_route[0], "", "Cố định tuyến")
    elif len(fixed_route) > 1:
        return ("", '; '.join(fixed_route), "Linh hoạt tuyến")
    elif len(flexible_route) > 1:
        return ("", '; '.join(flexible_route), "Linh hoạt tuyến")
    elif len(flexible_route) == 1:
        return ("", flexible_route[0], "Cố định tuyến")

    # Default if no routes are assigned
    return ('Chưa xác định', 'Chưa xác định', 'Chưa xác định')


# Áp dụng hàm cho từng khách hàng
customers_df[['Gán Tuyến Cố Định', 'Gán Tuyến Linh Hoạt', 'Loại điểm gán_Thanh']] = customers_df.apply(lambda row: pd.Series(assign_routes(row, layers_df)), axis=1)

# Xem trước dữ liệu đã phân loại
print(customers_df)

"""# Thêm 2 cột mã tuyến thanh và tuyến gán thanh"""

# Tạo cột mới "Tuyến gán_Thanh" bằng cách kết hợp "Gán Tuyến Cố Định" và "Gán Tuyến Linh Hoạt"
customers_df['Tuyến gán_Thanh'] = customers_df['Gán Tuyến Cố Định'].fillna('') + ' ' + customers_df['Gán Tuyến Linh Hoạt'].fillna('')

# Xóa khoảng trắng dư thừa nếu có
customers_df['Tuyến gán_Thanh'] = customers_df['Tuyến gán_Thanh'].str.strip()
# Tạo một hàm để tìm và ghép mã tuyến từ tuyen_xe_moi_df vào cột "Tuyến gán_Thanh"
def get_ma_tuyen(tuyen_gan, tuyen_xe_moi_df):
    ma_tuyen_list = []
    # Kiểm tra từng "Tuyến con" trong tuyen_xe_moi_df có xuất hiện trong "Tuyến gán_Thanh"
    for idx, row in tuyen_xe_moi_df.iterrows():
        if any(tuyen in tuyen_gan for tuyen in row['Tuyến con'].split(';')):
            ma_tuyen_list.append(row['Mã tuyến'])
    # Nếu có nhiều mã tuyến, trả về danh sách mã tuyến, ngược lại trả về giá trị đơn lẻ
    return '; '.join(ma_tuyen_list) if ma_tuyen_list else None

# Áp dụng hàm trên cho từng hàng trong customers_df để tạo cột "Mã tuyến_Thanh"
customers_df['Mã tuyến_Thanh'] = customers_df['Tuyến gán_Thanh'].apply(lambda x: get_ma_tuyen(x, tuyen_xe_moi_df))

# Kiểm tra kết quả
print(customers_df[['Tuyến gán_Thanh','Loại điểm gán_Thanh', 'Mã tuyến_Thanh']].head())

# Xem trước kết quả sau khi xử lý
print(customers_df[['Tuyến gán_Thanh', 'Mã tuyến_Thanh', 'Gán Tuyến Cố Định', 'Gán Tuyến Linh Hoạt', 'Loại điểm gán_Thanh']].head())

customers_df.value_counts('Loại điểm gán_Thanh')

# Lọc các khách hàng có "Loại điểm gán_Thanh" là "Chưa xác định" và cột "Kinh Độ" trống
chua_xac_dinh_df = customers_df[(customers_df['Loại điểm gán_Thanh'] == 'Chưa xác định') & (customers_df['Kinh Độ'].isna())]

# Hàm lookup sử dụng fuzzy matching để tìm tuyến con
def lookup_tuyen_con(tuyen_gan, tuyen_xe_cu, threshold=95):
    if pd.isna(tuyen_gan) or not isinstance(tuyen_gan, str):
        return []  # Trả về danh sách rỗng nếu giá trị không hợp lệ

    ma_tuyen_list = tuyen_gan.split(',')
    tuyen_con_list = []

    for ma_tuyen in ma_tuyen_list:
        # Sử dụng fuzzy matching trực tiếp với hàm ratio của rapidfuzz
        match = process.extractOne(ma_tuyen.strip(), tuyen_xe_cu['Mã tuyến'], scorer=fuzz.ratio)
        if match and match[1] >= threshold:  # match[1] là tỷ lệ phần trăm phù hợp
            tuyen_con = tuyen_xe_cu[tuyen_xe_cu['Mã tuyến'] == match[0]]['Tuyến con'].values
            if len(tuyen_con) > 0:
                tuyen_con_list.append(tuyen_con[0])

    # Loại bỏ các giá trị trùng lặp trong danh sách tuyến con
    tuyen_con_list = list(set(tuyen_con_list))

    return tuyen_con_list

# Áp dụng hàm lookup cho các khách hàng chưa xác định tuyến
def assign_route_by_match(row):
    tuyen_con_list = lookup_tuyen_con(row['Tuyến gán'], tuyen_xe_cu_df)

    if len(tuyen_con_list) > 2:
        # Gán vào cột "Gán Tuyến Linh Hoạt"
        return pd.Series(["", ', '.join(tuyen_con_list), "Linh hoạt tuyến"])
    elif len(tuyen_con_list) > 0:
        # Gán vào cột "Gán Tuyến Cố Định"
        return pd.Series([', '.join(tuyen_con_list), "", "Cố định tuyến"])
    else:
        # Trường hợp không tìm thấy tuyến con nào
        return pd.Series(["Chưa xác định", "Chưa xác định", "Chưa xác định"])

# Áp dụng hàm assign_route_by_match cho các khách hàng chưa xác định tuyến
chua_xac_dinh_df[['Gán Tuyến Cố Định', 'Gán Tuyến Linh Hoạt', 'Loại điểm gán_Thanh']] = chua_xac_dinh_df.apply(assign_route_by_match, axis=1)

# Tạo cột "Tuyến gán_Thanh" bằng cách nối "Gán Tuyến Cố Định" và "Gán Tuyến Linh Hoạt"
chua_xac_dinh_df['Tuyến gán_Thanh'] = chua_xac_dinh_df[['Gán Tuyến Cố Định', 'Gán Tuyến Linh Hoạt']].apply(
    lambda x: ', '.join(filter(None, x)), axis=1)

# Sao chép lại cột "Tuyến gán" thành "Mã tuyến_Thanh"
chua_xac_dinh_df['Mã tuyến_Thanh'] = chua_xac_dinh_df['Tuyến gán']

# Xem trước kết quả sau khi xử lý
print(chua_xac_dinh_df[['Tuyến gán_Thanh', 'Mã tuyến_Thanh', 'Gán Tuyến Cố Định', 'Gán Tuyến Linh Hoạt', 'Loại điểm gán_Thanh']].head())

"""Vẫn trong phần thêm

# Đây là phần chèn không có cột nếu phần thêm ổn rồi thì phần chèn kh cần chạy
"""

from rapidfuzz import process, fuzz

# Lọc các khách hàng có "Loại điểm gán_Thanh" là "Chưa xác định" và cột "Kinh Độ" trống
chua_xac_dinh_df = customers_df[(customers_df['Loại điểm gán_Thanh'] == 'Chưa xác định') & (customers_df['Kinh Độ'].isna())]

# Hàm lookup sử dụng fuzzy matching để tìm tuyến con
def lookup_tuyen_con(tuyen_gan, tuyen_xe, threshold=80):
    if pd.isna(tuyen_gan) or not isinstance(tuyen_gan, str):
        return []  # Trả về danh sách rỗng nếu giá trị không hợp lệ

    ma_tuyen_list = tuyen_gan.split(',')
    tuyen_con_list = []

    for ma_tuyen in ma_tuyen_list:
        # Sử dụng fuzzy matching trực tiếp với hàm ratio của rapidfuzz
        match = process.extractOne(ma_tuyen.strip(), tuyen_xe['Mã tuyến'], scorer=fuzz.ratio)
        if match and match[1] >= threshold:  # match[1] là tỷ lệ phần trăm phù hợp
            tuyen_con = tuyen_xe[tuyen_xe['Mã tuyến'] == match[0]]['Tuyến con'].values
            if len(tuyen_con) > 0:
                tuyen_con_list.append(tuyen_con[0])

    # Loại bỏ các giá trị trùng lặp trong danh sách tuyến con
    tuyen_con_list = list(set(tuyen_con_list))

    return tuyen_con_list

# Áp dụng hàm lookup cho các khách hàng chưa xác định tuyến
def assign_route_by_match(row):
    tuyen_con_list = lookup_tuyen_con(row['Tuyến gán'], tuyen_xe_cu_df)

    if len(tuyen_con_list) > 2:
        # Gán vào cột "Gán Tuyến Linh Hoạt"
        return pd.Series(["", ', '.join(tuyen_con_list), "Linh hoạt tuyến"])
    elif len(tuyen_con_list) > 0:
        # Gán vào cột "Gán Tuyến Cố Định"
        return pd.Series([', '.join(tuyen_con_list), "", "Cố định tuyến"])
    else:
        # Trường hợp không tìm thấy tuyến con nào
        return pd.Series(["Chưa xác định", "Chưa xác định", "Chưa xác định"])

# Áp dụng hàm assign_route_by_match cho các khách hàng chưa xác định tuyến
chua_xac_dinh_df[['Gán Tuyến Cố Định', 'Gán Tuyến Linh Hoạt', 'Loại điểm gán_Thanh']] = chua_xac_dinh_df.apply(assign_route_by_match, axis=1)

# Xem trước kết quả
print(chua_xac_dinh_df)

"""Vẫn là phần chèn kh có thêm ha

# Update thêm với lưu file
"""

# Cập nhật lại vào bảng customers_df mà không tạo giá trị trùng lặp
customers_df.update(chua_xac_dinh_df)

# Lưu DataFrame dưới dạng CSV vào đường dẫn yêu cầu
path = "/content/drive/MyDrive/Data/Dữ liệu tuyến, khách hàng cần thiết/customers_df.csv"
customers_df.to_csv(path, index=False)